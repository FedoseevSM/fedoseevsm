/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/immutability-helper@3.1.1/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";function stringifiable(t){return"object"!=typeof t||"toString"in t?t:Object.prototype.toString.call(t).slice(8,-1)}Object.defineProperty(exports,"__esModule",{value:!0});var isProduction="object"==typeof process&&"production"===process.env.NODE_ENV;function invariant(t,n){if(!t){if(isProduction)throw new Error("Invariant failed");throw new Error(n())}}exports.invariant=invariant;var hasOwnProperty=Object.prototype.hasOwnProperty,splice=Array.prototype.splice,toString=Object.prototype.toString;function type(t){return toString.call(t).slice(8,-1)}var assign=Object.assign||function(t,n){return getAllKeys(n).forEach(function(e){hasOwnProperty.call(n,e)&&(t[e]=n[e])}),t},getAllKeys="function"==typeof Object.getOwnPropertySymbols?function(t){return Object.keys(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.keys(t)};function copy(t){return Array.isArray(t)?assign(t.constructor(t.length),t):"Map"===type(t)?new Map(t):"Set"===type(t)?new Set(t):t&&"object"==typeof t?assign(Object.create(Object.getPrototypeOf(t)),t):t}var Context=function(){function t(){this.commands=assign({},defaultCommands),this.update=this.update.bind(this),this.update.extend=this.extend=this.extend.bind(this),this.update.isEquals=function(t,n){return t===n},this.update.newContext=function(){return(new t).update}}return Object.defineProperty(t.prototype,"isEquals",{get:function(){return this.update.isEquals},set:function(t){this.update.isEquals=t},enumerable:!0,configurable:!0}),t.prototype.extend=function(t,n){this.commands[t]=n},t.prototype.update=function(t,n){var e=this,r="function"==typeof n?{$apply:n}:n;Array.isArray(t)&&Array.isArray(r)||invariant(!Array.isArray(r),function(){return"update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value."}),invariant("object"==typeof r&&null!==r,function(){return"update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the following commands: "+Object.keys(e.commands).join(", ")+"."});var a=t;return getAllKeys(r).forEach(function(n){if(hasOwnProperty.call(e.commands,n)){var i=t===a;a=e.commands[n](r[n],a,r,t),i&&e.isEquals(a,t)&&(a=t)}else{var o="Map"===type(t)?e.update(t.get(n),r[n]):e.update(t[n],r[n]),c="Map"===type(a)?a.get(n):a[n];e.isEquals(o,c)&&(void 0!==o||hasOwnProperty.call(t,n))||(a===t&&(a=copy(t)),"Map"===type(a)?a.set(n,o):a[n]=o)}}),a},t}();exports.Context=Context;var defaultCommands={$push:function(t,n,e){return invariantPushAndUnshift(n,e,"$push"),t.length?n.concat(t):n},$unshift:function(t,n,e){return invariantPushAndUnshift(n,e,"$unshift"),t.length?t.concat(n):n},$splice:function(t,n,e,r){return invariantSplices(n,e),t.forEach(function(t){invariantSplice(t),n===r&&t.length&&(n=copy(r)),splice.apply(n,t)}),n},$set:function(t,n,e){return invariantSet(e),t},$toggle:function(t,n){invariantSpecArray(t,"$toggle");var e=t.length?copy(n):n;return t.forEach(function(t){e[t]=!n[t]}),e},$unset:function(t,n,e,r){return invariantSpecArray(t,"$unset"),t.forEach(function(t){Object.hasOwnProperty.call(n,t)&&(n===r&&(n=copy(r)),delete n[t])}),n},$add:function(t,n,e,r){return invariantMapOrSet(n,"$add"),invariantSpecArray(t,"$add"),"Map"===type(n)?t.forEach(function(t){var e=t[0],a=t[1];n===r&&n.get(e)!==a&&(n=copy(r)),n.set(e,a)}):t.forEach(function(t){n!==r||n.has(t)||(n=copy(r)),n.add(t)}),n},$remove:function(t,n,e,r){return invariantMapOrSet(n,"$remove"),invariantSpecArray(t,"$remove"),t.forEach(function(t){n===r&&n.has(t)&&(n=copy(r)),n.delete(t)}),n},$merge:function(t,n,e,r){return invariantMerge(n,t),getAllKeys(t).forEach(function(e){t[e]!==n[e]&&(n===r&&(n=copy(r)),n[e]=t[e])}),n},$apply:function(t,n){return invariantApply(t),t(n)}},defaultContext=new Context;function invariantPushAndUnshift(t,n,e){invariant(Array.isArray(t),function(){return"update(): expected target of "+stringifiable(e)+" to be an array; got "+stringifiable(t)+"."}),invariantSpecArray(n[e],e)}function invariantSpecArray(t,n){invariant(Array.isArray(t),function(){return"update(): expected spec of "+stringifiable(n)+" to be an array; got "+stringifiable(t)+". Did you forget to wrap your parameter in an array?"})}function invariantSplices(t,n){invariant(Array.isArray(t),function(){return"Expected $splice target to be an array; got "+stringifiable(t)}),invariantSplice(n.$splice)}function invariantSplice(t){invariant(Array.isArray(t),function(){return"update(): expected spec of $splice to be an array of arrays; got "+stringifiable(t)+". Did you forget to wrap your parameters in an array?"})}function invariantApply(t){invariant("function"==typeof t,function(){return"update(): expected spec of $apply to be a function; got "+stringifiable(t)+"."})}function invariantSet(t){invariant(1===Object.keys(t).length,function(){return"Cannot have more than one key in an object with $set"})}function invariantMerge(t,n){invariant(n&&"object"==typeof n,function(){return"update(): $merge expects a spec of type 'object'; got "+stringifiable(n)}),invariant(t&&"object"==typeof t,function(){return"update(): $merge expects a target of type 'object'; got "+stringifiable(t)})}function invariantMapOrSet(t,n){var e=type(t);invariant("Map"===e||"Set"===e,function(){return"update(): "+stringifiable(n)+" expects a target of type Set or Map; got "+stringifiable(e)})}exports.isEquals=defaultContext.update.isEquals,exports.extend=defaultContext.extend,exports.default=defaultContext.update,exports.default.default=module.exports=assign(exports.default,exports);
//# sourceMappingURL=/sm/829bce614262faea46555d1f5b4ee9d8ab55fa8bd2701f2b4fb594901c2847c6.map